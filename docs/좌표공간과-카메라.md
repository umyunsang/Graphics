# OpenGL 좌표공간과 카메라

## 목차
- [[#좌표 변환 파이프라인]]
- [[#좌표 공간 (Coordinate Spaces)]]
- [[#카메라 (Camera)와 뷰 변환]]
- [[#gluLookAt 함수]]
- [[#투영 변환 (Projection)]]
- [[#뷰포트 변환]]
- [[#후면 제거 (Face Culling)]]
- [[#실전 예제]]

---

## 좌표 변환 파이프라인

OpenGL에서 3D 객체의 정점은 최종 화면에 그려지기까지 여러 좌표 공간을 거치며 변환됩니다.

### 전체 파이프라인 흐름

```
물체 좌표 (Object/Model Space)
    ↓ [모델 변환 - Model Transform]
월드 좌표 (World Space)
    ↓ [뷰 변환 - View Transform]
시점 좌표 (Eye/Camera/View Space)
    ↓ [투영 변환 - Projection Transform]
클립 좌표 (Clip Space)
    ↓ [원근 나눗셈 - Perspective Division]
정규화 장치 좌표 (NDC - Normalized Device Coordinates)
    ↓ [뷰포트 변환 - Viewport Transform]
윈도우 좌표 (Window/Screen Space)
```

> **중요**: 좌표 변환은 **여러 단계를 순차적으로** 거치며, 각 단계는 특정한 목적을 가지고 있습니다.

---

## 좌표 공간 (Coordinate Spaces)

### 1. 물체 좌표 (Object/Local/Model Space)

**정의**: 각 객체가 정의될 때 사용하는 **로컬 좌표계**입니다.

**특징**:
- 물체 자체의 중심이 원점 (0, 0, 0)
- 모델링 작업 시 사용하는 좌표계
- 각 물체는 독립적인 로컬 좌표계를 가짐

**예시**:
```cpp
// 큐브를 로컬 좌표계에서 정의
glBegin(GL_QUADS);
    glVertex3f(-1.0f, -1.0f, 1.0f);  // 큐브의 로컬 좌표
    glVertex3f(1.0f, -1.0f, 1.0f);
    glVertex3f(1.0f, 1.0f, 1.0f);
    glVertex3f(-1.0f, 1.0f, 1.0f);
glEnd();
```

---

### 2. 월드 좌표 (World Space)

**정의**: 씬(Scene) 전체의 **공통 좌표계**입니다.

**특징**:
- 모든 객체가 배치되는 전역 좌표계
- 물체 간의 상대적 위치를 정의
- 모델 변환(이동, 회전, 크기 조절)을 통해 물체 좌표를 월드 좌표로 변환

**모델 변환 함수**:
```cpp
glTranslatef(x, y, z);  // 이동
glRotatef(angle, x, y, z);  // 회전
glScalef(sx, sy, sz);  // 크기 조절
```

**예시**:
```cpp
// 첫 번째 큐브를 왼쪽에 배치
glPushMatrix();
    glTranslatef(-3.0f, 0.0f, 0.0f);  // 월드 공간에서 왼쪽으로 이동
    drawCube();
glPopMatrix();

// 두 번째 큐브를 오른쪽에 배치
glPushMatrix();
    glTranslatef(3.0f, 0.0f, 0.0f);  // 월드 공간에서 오른쪽으로 이동
    drawCube();
glPopMatrix();
```

---

### 3. 시점 좌표 (Eye/Camera/View Space)

**정의**: **카메라를 기준**으로 한 좌표계입니다.

**특징**:
- 카메라가 원점 (0, 0, 0)에 위치
- 카메라는 -Z 축을 바라봄 (OpenGL 관례)
- +Y는 위쪽, +X는 오른쪽
- 뷰 변환을 통해 월드 좌표를 시점 좌표로 변환

**뷰 변환**:
- `gluLookAt()` 함수를 사용하여 카메라 위치와 방향 설정
- 또는 수동으로 `glTranslatef`, `glRotatef`를 사용

> **핵심**: 카메라가 움직이는 것이 아니라, **세상 전체가 카메라의 반대 방향으로 움직입니다**.

---

### 4. 클립 좌표 (Clip Space)

**정의**: **투영 변환 후**의 좌표계입니다.

**특징**:
- 투영 행렬을 정점에 곱한 결과
- 동차 좌표(Homogeneous Coordinates) 형태: (x, y, z, w)
- 뷰 프러스텀(View Frustum) 밖의 정점은 클리핑됨

**투영 변환 함수**:
- `glOrtho()` - 직교 투영
- `gluPerspective()` - 원근 투영
- `glFrustum()` - 원근 투영 (저수준)

---

### 5. 정규화 장치 좌표 (NDC - Normalized Device Coordinates)

**정의**: 클립 좌표를 정규화한 좌표계입니다.

**특징**:
- 범위: **[-1, 1] × [-1, 1] × [-1, 1]** (큐브 형태)
- 원근 나눗셈(Perspective Division)을 통해 클립 좌표를 NDC로 변환
  - `(x', y', z') = (x/w, y/w, z/w)`
- 플랫폼 독립적인 좌표계

---

### 6. 윈도우 좌표 (Window/Screen Space)

**정의**: 실제 **화면 픽셀 좌표**입니다.

**특징**:
- 좌표 범위: `[0, width] × [0, height]`
- `glViewport()`로 설정
- 래스터화(Rasterization) 단계에서 사용

**뷰포트 변환**:
```cpp
glViewport(x, y, width, height);
```

---

## 카메라 (Camera)와 뷰 변환

### 카메라의 개념

OpenGL에는 **명시적인 카메라 객체가 없습니다**. 대신, 우리는 **ModelView 행렬**을 조작하여 카메라의 효과를 냅니다.

**핵심 원리**:
- 카메라가 움직이는 대신, **세상 전체를 반대 방향으로 움직입니다**.
- 예: 카메라를 +Z 방향으로 5 이동 = 세상을 -Z 방향으로 5 이동

### ModelView 행렬

**정의**: 모델 변환과 뷰 변환을 합친 행렬입니다.

```cpp
glMatrixMode(GL_MODELVIEW);  // ModelView 행렬 모드로 전환
glLoadIdentity();             // 단위 행렬로 초기화
```

**변환 순서**:
1. **뷰 변환 먼저** (카메라 설정)
2. **모델 변환** (객체 배치)

```cpp
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();

// 1단계: 뷰 변환 (카메라 설정)
gluLookAt(0, 0, 5,   // 카메라 위치
          0, 0, 0,   // 카메라가 바라보는 지점
          0, 1, 0);  // 카메라의 위 방향

// 2단계: 모델 변환 (객체 배치)
glTranslatef(2.0f, 0.0f, 0.0f);
glRotatef(45, 0, 1, 0);
drawCube();
```

> **주의**: OpenGL은 **행렬을 오른쪽에서 왼쪽으로** 곱하므로, 코드의 **역순**으로 적용됩니다.

---

## gluLookAt 함수

### 함수 원형

```cpp
void gluLookAt(
    GLdouble eyeX,    GLdouble eyeY,    GLdouble eyeZ,     // 카메라 위치
    GLdouble centerX, GLdouble centerY, GLdouble centerZ,  // 바라보는 지점
    GLdouble upX,     GLdouble upY,     GLdouble upZ       // 카메라의 위 방향
);
```

### 매개변수 설명

1. **Eye (카메라 위치)**:
   - `(eyeX, eyeY, eyeZ)`: 카메라가 위치한 3D 공간 좌표
   - 예: `(0, 0, 5)` - 카메라가 Z축에서 5만큼 떨어진 위치

2. **Center (시선 방향)**:
   - `(centerX, centerY, centerZ)`: 카메라가 바라보는 점
   - 예: `(0, 0, 0)` - 원점을 바라봄
   - 카메라의 **전방 벡터(forward vector)**를 결정

3. **Up (상향 벡터)**:
   - `(upX, upY, upZ)`: 카메라의 위쪽 방향을 정의하는 벡터
   - 일반적으로 `(0, 1, 0)` 사용 (Y축이 위)
   - 카메라의 **회전(roll)**을 결정

### 동작 원리

`gluLookAt`는 내부적으로 다음과 같은 3개의 벡터를 계산합니다:

1. **Forward (전방) 벡터**:
   ```
   F = normalize(center - eye)
   ```
   - 카메라가 바라보는 방향

2. **Right (오른쪽) 벡터**:
   ```
   R = normalize(F × up)
   ```
   - 카메라의 오른쪽 방향 (외적 사용)

3. **Up (위쪽) 벡터**:
   ```
   U = R × F
   ```
   - 카메라의 실제 위쪽 방향 (재계산됨)

이 3개의 벡터로 **회전 행렬**을 만들고, 카메라 위치로 **이동 행렬**을 만들어 ModelView 행렬에 곱합니다.

### 사용 예제

#### 예제 1: 기본 카메라 설정

```cpp
void ChangeSize(GLsizei w, GLsizei h) {
    if (h == 0) h = 1;
    GLfloat aspectRatio = (GLfloat)w / (GLfloat)h;

    // 투영 행렬 설정
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0f, aspectRatio, 1.0f, 100.0f);

    // ModelView 행렬 설정
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // 카메라 설정: Z축에서 5만큼 떨어진 곳에서 원점을 바라봄
    gluLookAt(0.0, 0.0, 5.0,   // 카메라 위치 (Eye)
              0.0, 0.0, 0.0,   // 바라보는 지점 (Center)
              0.0, 1.0, 0.0);  // 위 방향 (Up)
}
```

#### 예제 2: 카메라를 다양한 각도에서 배치

```cpp
// 정면에서 바라보기
gluLookAt(0, 0, 10,   // 카메라가 앞쪽에 위치
          0, 0, 0,    // 원점을 바라봄
          0, 1, 0);   // Y축이 위

// 위에서 내려다보기
gluLookAt(0, 10, 0,   // 카메라가 위에 위치
          0, 0, 0,    // 원점을 바라봄
          0, 0, -1);  // -Z축이 위 (화면 뒤쪽)

// 대각선에서 바라보기
gluLookAt(5, 5, 5,    // 카메라가 대각선 위치
          0, 0, 0,    // 원점을 바라봄
          0, 1, 0);   // Y축이 위
```

#### 예제 3: 객체 주위를 회전하는 카메라

```cpp
GLfloat angle = 0.0f;  // 회전 각도

void RenderScene(void) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // 카메라가 원형 궤도를 그리며 회전
    GLfloat eyeX = 5.0f * cos(angle);
    GLfloat eyeZ = 5.0f * sin(angle);

    gluLookAt(eyeX, 2.0, eyeZ,  // 카메라 위치
              0.0, 0.0, 0.0,     // 원점을 바라봄
              0.0, 1.0, 0.0);    // 위 방향

    // 객체 그리기
    glutSolidTeapot(1.0);

    glutSwapBuffers();
    angle += 0.01f;  // 각도 증가
}
```

### gluLookAt vs 수동 변환

#### 수동 변환 (glTranslatef, glRotatef)

```cpp
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();

// 카메라를 Z축에서 -5 이동 = 세상을 Z축에서 +5 이동
glTranslatef(0.0f, 0.0f, -5.0f);
```

**장점**:
- 단순한 이동/회전에 유용
- 직관적

**단점**:
- 복잡한 카메라 방향 설정이 어려움
- 회전 순서에 주의 필요 (짐벌락 문제)

#### gluLookAt 사용

```cpp
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();

gluLookAt(0, 0, 5,   // 카메라 위치
          0, 0, 0,   // 바라보는 지점
          0, 1, 0);  // 위 방향
```

**장점**:
- 카메라 위치와 방향을 직관적으로 설정
- 복잡한 카메라 움직임 구현이 쉬움
- 짐벌락 문제 없음

**단점**:
- 내부 동작을 이해하기 어려울 수 있음

> **권장**: 3D 장면에서는 `gluLookAt`를 사용하는 것이 일반적으로 더 편리합니다.

### gluLookAt 사용 시 주의사항

1. **Up 벡터와 Forward 벡터가 평행하면 안 됨**:
   ```cpp
   // ❌ 잘못된 예: up과 forward가 평행
   gluLookAt(0, 0, 5,   // eye
             0, 0, 0,   // center (forward = (0, 0, -1))
             0, 0, 1);  // up (평행!)

   // ✅ 올바른 예
   gluLookAt(0, 0, 5,   // eye
             0, 0, 0,   // center
             0, 1, 0);  // up (수직)
   ```

2. **ModelView 모드에서 호출**:
   ```cpp
   glMatrixMode(GL_MODELVIEW);  // 필수!
   glLoadIdentity();
   gluLookAt(...);
   ```

3. **호출 순서**:
   - `gluLookAt`는 `glLoadIdentity()` 직후에 호출
   - 모델 변환(glTranslatef, glRotatef)은 그 다음에 호출

---

## 투영 변환 (Projection)

### 투영의 종류

#### 1. 직교 투영 (Orthographic Projection)

**특징**:
- 평행 투영
- 거리에 관계없이 크기가 일정
- 원근감 없음

**함수**:
```cpp
void glOrtho(
    GLdouble left,   GLdouble right,   // X축 범위
    GLdouble bottom, GLdouble top,     // Y축 범위
    GLdouble near,   GLdouble far      // Z축 범위 (카메라로부터의 거리)
);
```

**사용 예**:
```cpp
glMatrixMode(GL_PROJECTION);
glLoadIdentity();

// -100 ~ 100 범위의 좌표계
glOrtho(-100, 100, -100, 100, -100, 100);
```

**활용**:
- 2D 게임
- UI/HUD
- CAD 프로그램
- 기술 도면

---

#### 2. 원근 투영 (Perspective Projection)

**특징**:
- 원근법 적용
- 멀리 있는 물체가 작게 보임
- 실제 사람의 시야와 유사

**함수 1: gluPerspective()**:
```cpp
void gluPerspective(
    GLdouble fovy,          // 시야각 (Field of View Y, 도 단위)
    GLdouble aspect,        // 종횡비 (width / height)
    GLdouble zNear,         // 가까운 클리핑 평면
    GLdouble zFar           // 먼 클리핑 평면
);
```

**사용 예**:
```cpp
glMatrixMode(GL_PROJECTION);
glLoadIdentity();

GLfloat aspectRatio = (GLfloat)width / (GLfloat)height;
gluPerspective(45.0,           // 시야각 45도
               aspectRatio,    // 화면 종횡비
               1.0,            // near = 1.0 (카메라에서 1.0 거리)
               100.0);         // far = 100.0 (카메라에서 100.0 거리)
```

**매개변수 설명**:
- `fovy`: 수직 시야각 (일반적으로 45도 ~ 60도 사용)
  - 작을수록: 망원렌즈 효과 (확대)
  - 클수록: 광각렌즈 효과 (넓은 시야)
- `aspect`: 종횡비 (창의 너비/높이)
- `zNear`, `zFar`: 클리핑 평면의 거리
  - **주의**: `zNear`는 **0보다 커야 함** (양수)
  - `zNear` ~ `zFar` 범위 밖의 물체는 보이지 않음

**함수 2: glFrustum()** (저수준):
```cpp
void glFrustum(
    GLdouble left,   GLdouble right,   // X축 범위 (near 평면에서)
    GLdouble bottom, GLdouble top,     // Y축 범위 (near 평면에서)
    GLdouble near,   GLdouble far      // 클리핑 평면 거리
);
```

**사용 예**:
```cpp
glMatrixMode(GL_PROJECTION);
glLoadIdentity();

glFrustum(-1.0, 1.0,      // X: -1 ~ 1
          -1.0, 1.0,      // Y: -1 ~ 1
          1.0, 100.0);    // Z: 1 ~ 100
```

> **gluPerspective vs glFrustum**:
> - `gluPerspective`는 대칭적인 뷰 프러스텀을 생성 (일반적)
> - `glFrustum`은 비대칭 뷰 프러스텀 생성 가능 (특수한 경우)

---

### 투영 설정 예제

#### 예제 1: 기본 원근 투영

```cpp
void ChangeSize(GLsizei w, GLsizei h) {
    if (h == 0) h = 1;

    glViewport(0, 0, w, h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    GLfloat aspectRatio = (GLfloat)w / (GLfloat)h;
    gluPerspective(45.0f, aspectRatio, 1.0f, 100.0f);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}
```

#### 예제 2: 직교 투영 (종횡비 보정)

```cpp
void ChangeSize(GLsizei w, GLsizei h) {
    if (h == 0) h = 1;

    glViewport(0, 0, w, h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    GLfloat aspectRatio = (GLfloat)w / (GLfloat)h;
    GLfloat size = 100.0f;

    if (w <= h) {
        // 세로가 더 길 때: Y축 확장
        glOrtho(-size, size,
                -size / aspectRatio, size / aspectRatio,
                -size, size);
    } else {
        // 가로가 더 길 때: X축 확장
        glOrtho(-size * aspectRatio, size * aspectRatio,
                -size, size,
                -size, size);
    }

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}
```

---

### 뷰 프러스텀 (View Frustum)

**정의**: 카메라가 볼 수 있는 **3D 공간의 범위**입니다.

**형태**:
- **직교 투영**: 직육면체 (Box)
- **원근 투영**: 절두체 (Frustum, 잘린 피라미드)

**클리핑 평면**:
- **Near Plane**: 가까운 클리핑 평면
- **Far Plane**: 먼 클리핑 평면
- **Left, Right, Top, Bottom**: 좌우상하 경계

**클리핑**:
- 뷰 프러스텀 밖의 정점/면은 렌더링되지 않음 (잘림)
- 성능 최적화에 중요

```
        Far Plane
        +-------+
       /|      /|
      / |     / |
     /  |    /  |
    +-------+   |  <- View Frustum (원근 투영)
    |   +---|---+
    |  /    |  / Near Plane
    | /     | /
    |/      |/
    +-------+ <- Eye (Camera)
```

---

## 뷰포트 변환

### glViewport 함수

**정의**: NDC 좌표를 화면 픽셀 좌표로 변환합니다.

**함수 원형**:
```cpp
void glViewport(
    GLint x,      // 뷰포트 왼쪽 하단 X 좌표 (픽셀)
    GLint y,      // 뷰포트 왼쪽 하단 Y 좌표 (픽셀)
    GLsizei width,  // 뷰포트 너비 (픽셀)
    GLsizei height  // 뷰포트 높이 (픽셀)
);
```

**사용 예**:
```cpp
void ChangeSize(GLsizei w, GLsizei h) {
    if (h == 0) h = 1;

    // 전체 창을 뷰포트로 사용
    glViewport(0, 0, w, h);

    // ... 투영 설정 ...
}
```

### Viewport의 역할

- NDC 범위 `[-1, 1]`을 화면 픽셀로 매핑
- X: `[-1, 1]` → `[x, x + width]`
- Y: `[-1, 1]` → `[y, y + height]`

### 다중 뷰포트

화면을 여러 영역으로 나누어 각각 다른 시점을 표시할 수 있습니다.

```cpp
void RenderScene(void) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // 왼쪽 절반 - 정면 뷰
    glViewport(0, 0, windowWidth / 2, windowHeight);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(0, 0, 10,  0, 0, 0,  0, 1, 0);
    drawScene();

    // 오른쪽 절반 - 측면 뷰
    glViewport(windowWidth / 2, 0, windowWidth / 2, windowHeight);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(10, 0, 0,  0, 0, 0,  0, 1, 0);
    drawScene();

    glutSwapBuffers();
}
```

---

## 후면 제거 (Face Culling)

### 개념

**정의**: 3D 모델에서 카메라를 향하지 않는 뒷면(Back Face)을 렌더링하지 않는 최적화 기법입니다.

**목적**:
- **성능 향상**: 보이지 않는 면을 그리지 않아 렌더링 속도 증가 (약 50% 성능 향상)
- **불필요한 계산 제거**: 프래그먼트 셰이더 실행 횟수 감소

**원리**:
- 닫힌 3D 객체(예: 큐브, 구)에서는 항상 절반의 면만 보임
- 뒷면을 그리지 않아도 시각적으로 차이 없음

---

### 정면과 뒷면 구분

OpenGL은 정점의 **와인딩 순서(Winding Order)**로 정면/뒷면을 구분합니다.

#### 와인딩 순서

**반시계 방향 (CCW - Counter-Clockwise)**: 정면 (기본값)
```cpp
// 정면을 바라볼 때 정점이 반시계 방향
glBegin(GL_TRIANGLES);
    glVertex3f(0.0f, 1.0f, 0.0f);   // 위
    glVertex3f(-1.0f, -1.0f, 0.0f); // 왼쪽 아래
    glVertex3f(1.0f, -1.0f, 0.0f);  // 오른쪽 아래
glEnd();
```

**시계 방향 (CW - Clockwise)**: 뒷면 (기본값)
```cpp
// 정면을 바라볼 때 정점이 시계 방향
glBegin(GL_TRIANGLES);
    glVertex3f(0.0f, 1.0f, 0.0f);   // 위
    glVertex3f(1.0f, -1.0f, 0.0f);  // 오른쪽 아래
    glVertex3f(-1.0f, -1.0f, 0.0f); // 왼쪽 아래
glEnd();
```

**시각화**:
```
    반시계 방향 (CCW)         시계 방향 (CW)
         (Front)               (Back)

           v0                     v0
          / \                    / \
         /   \                  /   \
        /     \                /     \
       v1 ←--- v2             v1 ---→ v2
```

> **중요**: 와인딩 순서는 **카메라 기준**입니다. 즉, 뷰 변환 후 화면에 투영된 상태에서 판단합니다.

---

### 후면 제거 함수

#### 1. glEnable(GL_CULL_FACE)

**후면 제거 활성화**:
```cpp
glEnable(GL_CULL_FACE);   // 후면 제거 켜기
```

**후면 제거 비활성화**:
```cpp
glDisable(GL_CULL_FACE);  // 후면 제거 끄기 (기본값)
```

> **기본 상태**: OpenGL은 기본적으로 후면 제거가 **비활성화**되어 있습니다.

---

#### 2. glCullFace() - 제거할 면 선택

**함수 원형**:
```cpp
void glCullFace(GLenum mode);
```

**매개변수**:
- `GL_BACK`: 뒷면 제거 **(기본값, 가장 일반적)**
- `GL_FRONT`: 정면 제거 (특수한 경우)
- `GL_FRONT_AND_BACK`: 양면 모두 제거 (아무것도 안 그려짐)

**사용 예**:
```cpp
glEnable(GL_CULL_FACE);       // 후면 제거 활성화
glCullFace(GL_BACK);          // 뒷면 제거 (일반적)
```

**활용 시나리오**:

| 설정 | 용도 |
|------|------|
| `GL_BACK` | 일반적인 3D 모델 (큐브, 구 등) |
| `GL_FRONT` | 카메라가 물체 안쪽에 있을 때 (예: 스카이박스) |
| `GL_FRONT_AND_BACK` | 디버깅 목적 (아무것도 안 보임) |

---

#### 3. glFrontFace() - 정면 방향 정의

**함수 원형**:
```cpp
void glFrontFace(GLenum mode);
```

**매개변수**:
- `GL_CCW`: 반시계 방향이 정면 **(기본값)**
- `GL_CW`: 시계 방향이 정면

**사용 예**:
```cpp
glFrontFace(GL_CCW);  // 반시계 방향을 정면으로 (기본값)
```

**언제 사용?**:
- 기존 모델의 정점 순서를 바꾸지 않고, 정면/뒷면 정의만 바꾸고 싶을 때
- 일부 모델링 도구에서 내보낸 모델이 다른 와인딩 순서를 사용할 때

```cpp
// 시계 방향 정점으로 정의된 모델을 로드한 경우
glFrontFace(GL_CW);  // 시계 방향을 정면으로 변경
glEnable(GL_CULL_FACE);
glCullFace(GL_BACK);
```

---

### 후면 제거 사용 예제

#### 예제 1: 기본 큐브에 후면 제거 적용

```cpp
void SetupRC(void) {
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

    // 후면 제거 활성화
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);     // 뒷면 제거
    glFrontFace(GL_CCW);     // 반시계 방향이 정면

    // 깊이 테스트도 함께 활성화 (필수)
    glEnable(GL_DEPTH_TEST);
}

void drawCube(void) {
    glBegin(GL_QUADS);
        // 앞면 (반시계 방향으로 정의)
        glColor3f(1.0f, 0.0f, 0.0f);  // 빨강
        glVertex3f(-1.0f, -1.0f, 1.0f);  // 왼쪽 아래
        glVertex3f(1.0f, -1.0f, 1.0f);   // 오른쪽 아래
        glVertex3f(1.0f, 1.0f, 1.0f);    // 오른쪽 위
        glVertex3f(-1.0f, 1.0f, 1.0f);   // 왼쪽 위

        // 뒷면 (반시계 방향으로 정의)
        glColor3f(0.0f, 1.0f, 0.0f);  // 초록
        glVertex3f(1.0f, -1.0f, -1.0f);  // 오른쪽 아래
        glVertex3f(-1.0f, -1.0f, -1.0f); // 왼쪽 아래
        glVertex3f(-1.0f, 1.0f, -1.0f);  // 왼쪽 위
        glVertex3f(1.0f, 1.0f, -1.0f);   // 오른쪽 위

        // 왼쪽면
        glColor3f(0.0f, 0.0f, 1.0f);  // 파랑
        glVertex3f(-1.0f, -1.0f, -1.0f);
        glVertex3f(-1.0f, -1.0f, 1.0f);
        glVertex3f(-1.0f, 1.0f, 1.0f);
        glVertex3f(-1.0f, 1.0f, -1.0f);

        // 오른쪽면
        glColor3f(1.0f, 1.0f, 0.0f);  // 노랑
        glVertex3f(1.0f, -1.0f, 1.0f);
        glVertex3f(1.0f, -1.0f, -1.0f);
        glVertex3f(1.0f, 1.0f, -1.0f);
        glVertex3f(1.0f, 1.0f, 1.0f);

        // 위면
        glColor3f(1.0f, 0.0f, 1.0f);  // 자홍
        glVertex3f(-1.0f, 1.0f, 1.0f);
        glVertex3f(1.0f, 1.0f, 1.0f);
        glVertex3f(1.0f, 1.0f, -1.0f);
        glVertex3f(-1.0f, 1.0f, -1.0f);

        // 아래면
        glColor3f(0.0f, 1.0f, 1.0f);  // 청록
        glVertex3f(-1.0f, -1.0f, -1.0f);
        glVertex3f(1.0f, -1.0f, -1.0f);
        glVertex3f(1.0f, -1.0f, 1.0f);
        glVertex3f(-1.0f, -1.0f, 1.0f);
    glEnd();
}
```

---

#### 예제 2: 후면 제거 전후 비교

```cpp
bool cullingEnabled = true;  // 토글 변수

void RenderScene(void) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    gluLookAt(3.0, 3.0, 3.0,   // 카메라 위치
              0.0, 0.0, 0.0,   // 원점을 바라봄
              0.0, 1.0, 0.0);  // 위 방향

    // 후면 제거 토글
    if (cullingEnabled) {
        glEnable(GL_CULL_FACE);
    } else {
        glDisable(GL_CULL_FACE);
    }

    // 큐브를 회전시켜 그리기
    static float angle = 0.0f;
    glRotatef(angle, 0.0f, 1.0f, 0.0f);
    drawCube();
    angle += 0.5f;

    glutSwapBuffers();
}

void Keyboard(unsigned char key, int x, int y) {
    switch(key) {
        case 'c':  // 'c' 키로 후면 제거 토글
        case 'C':
            cullingEnabled = !cullingEnabled;
            if (cullingEnabled) {
                printf("후면 제거: 활성화\n");
            } else {
                printf("후면 제거: 비활성화\n");
            }
            glutPostRedisplay();
            break;
    }
}
```

---

#### 예제 3: 스카이박스 (카메라 내부에서 바라보기)

스카이박스는 카메라가 **큐브 안쪽**에서 바라보는 구조이므로, **정면을 제거**해야 합니다.

```cpp
void drawSkybox(void) {
    glDisable(GL_DEPTH_TEST);  // 깊이 테스트 끄기 (항상 뒤에 그려지도록)

    // 정면 제거 (내부에서 바라보므로)
    glEnable(GL_CULL_FACE);
    glCullFace(GL_FRONT);  // 정면 제거!

    // 큐브 그리기 (큰 크기)
    glPushMatrix();
        glScalef(100.0f, 100.0f, 100.0f);  // 큰 박스
        drawCube();  // 반시계 방향으로 정의된 큐브
    glPopMatrix();

    // 원래 설정으로 복원
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
}
```

---

### 후면 제거와 깊이 테스트

후면 제거는 **깊이 테스트(Depth Test)**와 함께 사용하는 것이 일반적입니다.

**깊이 테스트**:
```cpp
glEnable(GL_DEPTH_TEST);  // 깊이 테스트 활성화
```

**초기화 시 설정**:
```cpp
void SetupRC(void) {
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

    // 깊이 테스트와 후면 제거 함께 사용
    glEnable(GL_DEPTH_TEST);   // 깊이 테스트
    glEnable(GL_CULL_FACE);    // 후면 제거
    glCullFace(GL_BACK);       // 뒷면 제거
}

void RenderScene(void) {
    // 색상 버퍼와 깊이 버퍼 모두 초기화
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // ... 렌더링 코드 ...
}
```

**디스플레이 모드 설정** (main 함수):
```cpp
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);  // GLUT_DEPTH 필수!
```

---

### 와인딩 순서 확인 방법

정점 순서가 올바른지 확인하려면:

1. **정면만 그리기**:
   ```cpp
   glEnable(GL_CULL_FACE);
   glCullFace(GL_BACK);  // 뒷면 제거
   ```
   → 정상적으로 보여야 함

2. **뒷면만 그리기**:
   ```cpp
   glEnable(GL_CULL_FACE);
   glCullFace(GL_FRONT);  // 정면 제거
   ```
   → 아무것도 안 보이거나 이상하게 보여야 함

3. **와인딩 순서 디버깅**:
   ```cpp
   glDisable(GL_CULL_FACE);  // 후면 제거 끄기
   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);  // 와이어프레임 모드
   ```
   → 모든 면의 구조를 확인

---

### 주의사항

#### 1. 정점 순서 일관성

**모든 면의 정점을 같은 방향**으로 정의해야 합니다.

❌ **잘못된 예** (일관성 없음):
```cpp
glBegin(GL_QUADS);
    // 앞면 - 반시계 방향
    glVertex3f(-1, -1, 1);
    glVertex3f(1, -1, 1);
    glVertex3f(1, 1, 1);
    glVertex3f(-1, 1, 1);

    // 뒷면 - 시계 방향 (잘못됨!)
    glVertex3f(-1, -1, -1);
    glVertex3f(-1, 1, -1);
    glVertex3f(1, 1, -1);
    glVertex3f(1, -1, -1);
glEnd();
```

✅ **올바른 예** (모두 반시계 방향):
```cpp
glBegin(GL_QUADS);
    // 앞면 - 반시계 방향
    glVertex3f(-1, -1, 1);
    glVertex3f(1, -1, 1);
    glVertex3f(1, 1, 1);
    glVertex3f(-1, 1, 1);

    // 뒷면 - 반시계 방향 (카메라가 뒷면을 볼 때 기준)
    glVertex3f(1, -1, -1);  // 오른쪽 아래
    glVertex3f(-1, -1, -1); // 왼쪽 아래
    glVertex3f(-1, 1, -1);  // 왼쪽 위
    glVertex3f(1, 1, -1);   // 오른쪽 위
glEnd();
```

---

#### 2. 닫힌 객체에만 사용

후면 제거는 **닫힌(Closed) 3D 객체**에만 적합합니다.

**적합한 경우**:
- 큐브, 구, 원기둥, 주전자 등 닫힌 표면
- 3D 캐릭터 모델

**부적합한 경우**:
- 단면 평면 (예: 단일 사각형, 바닥)
- 얇은 벽 (양면이 다 보여야 하는 경우)
- 투명한 객체 (양면을 그려야 할 수 있음)

**해결책** (양면 모두 보이게):
```cpp
glDisable(GL_CULL_FACE);  // 후면 제거 끄기
```

---

#### 3. 변환과 와인딩 순서

**음수 스케일 변환**을 사용하면 와인딩 순서가 뒤집힐 수 있습니다.

```cpp
// 음수 스케일 사용 시 와인딩 순서 반전
glScalef(-1.0f, 1.0f, 1.0f);  // X축 반전

// 해결책: 정면 방향 변경
glFrontFace(GL_CW);  // 임시로 시계 방향을 정면으로
drawCube();
glFrontFace(GL_CCW); // 원래대로 복원
```

---

#### 4. 투명 객체

**투명 객체는 후면도 그려야** 제대로 보입니다.

```cpp
// 투명 객체 그리기
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

// 후면 제거 끄기
glDisable(GL_CULL_FACE);

// 투명 객체 그리기
glColor4f(1.0f, 0.0f, 0.0f, 0.5f);  // 반투명 빨강
drawCube();

// 후면 제거 다시 켜기
glEnable(GL_CULL_FACE);
glDisable(GL_BLEND);
```

---

### 성능 비교

**후면 제거 비활성화** (기본값):
- 모든 면을 그림 → **느림**
- 프래그먼트 셰이더가 모든 픽셀에 대해 실행됨

**후면 제거 활성화**:
- 약 절반의 면만 그림 → **빠름** (약 50% 성능 향상)
- 프래그먼트 셰이더 실행 횟수 감소

**측정 예시** (1000개의 큐브 렌더링):
```
후면 제거 비활성화: 30 FPS
후면 제거 활성화:   60 FPS (2배 빠름)
```

---

### 요약 및 권장 설정

#### 일반적인 3D 장면

```cpp
void SetupRC(void) {
    // 배경색
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

    // 깊이 테스트 (필수)
    glEnable(GL_DEPTH_TEST);

    // 후면 제거 (권장)
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);     // 뒷면 제거
    glFrontFace(GL_CCW);     // 반시계 방향이 정면
}

void RenderScene(void) {
    // 버퍼 초기화
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // 렌더링...
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);  // DEPTH 필수
    // ...
}
```

#### 체크리스트

- [ ] `glEnable(GL_DEPTH_TEST)` - 깊이 테스트 활성화
- [ ] `glEnable(GL_CULL_FACE)` - 후면 제거 활성화
- [ ] `glCullFace(GL_BACK)` - 뒷면 제거 (일반적)
- [ ] `glFrontFace(GL_CCW)` - 반시계 방향이 정면 (기본값)
- [ ] `glutInitDisplayMode(...| GLUT_DEPTH)` - 깊이 버퍼 생성
- [ ] `glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)` - 버퍼 초기화
- [ ] 모든 면의 정점을 **반시계 방향**으로 일관되게 정의

---

## 실전 예제

### 예제 1: 3D 큐브를 다양한 각도에서 보기

```cpp
#include <GL/glut.h>

void drawCube(void) {
    glBegin(GL_QUADS);
        // 앞면
        glColor3f(1.0f, 0.0f, 0.0f);  // 빨강
        glVertex3f(-1.0f, -1.0f, 1.0f);
        glVertex3f(1.0f, -1.0f, 1.0f);
        glVertex3f(1.0f, 1.0f, 1.0f);
        glVertex3f(-1.0f, 1.0f, 1.0f);

        // 뒷면
        glColor3f(0.0f, 1.0f, 0.0f);  // 초록
        glVertex3f(-1.0f, -1.0f, -1.0f);
        glVertex3f(-1.0f, 1.0f, -1.0f);
        glVertex3f(1.0f, 1.0f, -1.0f);
        glVertex3f(1.0f, -1.0f, -1.0f);

        // (나머지 면들...)
    glEnd();
}

void RenderScene(void) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // 카메라를 대각선 위에 배치
    gluLookAt(3.0, 3.0, 3.0,   // 카메라 위치
              0.0, 0.0, 0.0,   // 원점을 바라봄
              0.0, 1.0, 0.0);  // Y축이 위

    // 큐브 그리기
    drawCube();

    glutSwapBuffers();
}

void ChangeSize(GLsizei w, GLsizei h) {
    if (h == 0) h = 1;

    glViewport(0, 0, w, h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    GLfloat aspectRatio = (GLfloat)w / (GLfloat)h;
    gluPerspective(45.0f, aspectRatio, 1.0f, 100.0f);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(640, 480);
    glutCreateWindow("3D Cube with Camera");

    glEnable(GL_DEPTH_TEST);  // 깊이 테스트 활성화

    glutDisplayFunc(RenderScene);
    glutReshapeFunc(ChangeSize);

    glutMainLoop();
    return 0;
}
```

---

### 예제 2: 카메라 위치를 키보드로 조작

```cpp
// 카메라 위치
GLfloat eyeX = 0.0f, eyeY = 0.0f, eyeZ = 5.0f;

void RenderScene(void) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // 카메라 설정 (동적)
    gluLookAt(eyeX, eyeY, eyeZ,   // 카메라 위치
              0.0, 0.0, 0.0,      // 원점을 바라봄
              0.0, 1.0, 0.0);     // Y축이 위

    // 객체 그리기
    glutSolidTeapot(1.0);

    glutSwapBuffers();
}

void Keyboard(unsigned char key, int x, int y) {
    switch(key) {
        case 'w': eyeZ -= 0.5f; break;  // 앞으로
        case 's': eyeZ += 0.5f; break;  // 뒤로
        case 'a': eyeX -= 0.5f; break;  // 왼쪽으로
        case 'd': eyeX += 0.5f; break;  // 오른쪽으로
        case 'q': eyeY += 0.5f; break;  // 위로
        case 'e': eyeY -= 0.5f; break;  // 아래로
    }
    glutPostRedisplay();  // 화면 갱신 요청
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(640, 480);
    glutCreateWindow("Camera Control");

    glEnable(GL_DEPTH_TEST);

    glutDisplayFunc(RenderScene);
    glutReshapeFunc(ChangeSize);
    glutKeyboardFunc(Keyboard);  // 키보드 콜백 등록

    glutMainLoop();
    return 0;
}
```

---

## 시험 대비 핵심 요약

### 좌표 변환 순서

```
물체 좌표 → (모델 변환) → 월드 좌표 → (뷰 변환) → 시점 좌표
→ (투영 변환) → 클립 좌표 → (원근 나눗셈) → NDC → (뷰포트 변환) → 윈도우 좌표
```

### 행렬 모드

- `GL_MODELVIEW`: 모델 변환 + 뷰 변환 (카메라)
- `GL_PROJECTION`: 투영 변환 (직교/원근)
- `GL_TEXTURE`: 텍스처 변환

### gluLookAt 핵심

```cpp
gluLookAt(eyeX, eyeY, eyeZ,       // 카메라 위치
          centerX, centerY, centerZ, // 바라보는 지점
          upX, upY, upZ);           // 위 방향
```

- ModelView 행렬에 영향
- `glLoadIdentity()` 직후 호출
- 카메라가 -Z축을 바라봄 (OpenGL 관례)

### 투영 변환

**직교 투영**:
```cpp
glOrtho(left, right, bottom, top, near, far);
```
- 평행 투영, 크기 일정

**원근 투영**:
```cpp
gluPerspective(fovy, aspect, zNear, zFar);
```
- 원근법, `zNear > 0` 필수

### 뷰포트

```cpp
glViewport(x, y, width, height);
```
- NDC를 픽셀로 변환
- 창 크기 변경 시 재설정 필요

### 후면 제거 핵심

**활성화**:
```cpp
glEnable(GL_CULL_FACE);   // 후면 제거 켜기
glCullFace(GL_BACK);      // 뒷면 제거 (일반적)
glFrontFace(GL_CCW);      // 반시계 방향이 정면 (기본값)
```

**와인딩 순서**:
- 반시계 방향 (CCW): 정면
- 시계 방향 (CW): 뒷면

**주요 함수**:
- `glEnable(GL_CULL_FACE)` - 후면 제거 활성화
- `glCullFace(GL_BACK)` - 뒷면 제거
- `glCullFace(GL_FRONT)` - 정면 제거 (스카이박스용)
- `glFrontFace(GL_CCW)` - 정면 방향 정의

### 주의사항

1. **행렬 모드 전환 후 반드시 복귀**
2. **뷰 변환은 모델 변환보다 먼저 호출**
3. **원근 투영에서 zNear는 0보다 커야 함**
4. **깊이 테스트 활성화**: `glEnable(GL_DEPTH_TEST)`
5. **gluLookAt의 up 벡터는 forward와 평행하면 안 됨**
6. **후면 제거는 깊이 테스트와 함께 사용**
7. **모든 면의 정점을 같은 와인딩 순서로 정의**

---

## 참고 자료

- [OpenGL Red Book](https://www.glprogramming.com/red/)
- [LearnOpenGL - Coordinate Systems](https://learnopengl.com/Getting-started/Coordinate-Systems)
- [OpenGL Projection Matrix](http://www.songho.ca/opengl/gl_projectionmatrix.html)

---

**마지막 업데이트**: 2025-11-26
