# 깊이 버퍼와 투영

## 깊이 버퍼 (Depth Buffer)

### 개념
- **목적**: 3D 장면에서 가려진 면을 자동으로 제거
- **원리**: 각 픽셀마다 관측자(카메라)로부터의 거리(깊이 값)를 저장
- **동작**: 같은 화면 위치에 여러 픽셀이 그려질 때 깊이 값을 비교하여 더 가까운 픽셀만 표시

### OpenGL에서의 깊이 테스트

```cpp
// 1. 초기화 단계
glutInitDisplayMode(GLUT_DEPTH);  // 깊이 버퍼 할당

// 2. 렌더링 단계
glClear(GL_DEPTH_BUFFER_BIT);     // 깊이 버퍼 클리어
glEnable(GL_DEPTH_TEST);           // 깊이 테스트 활성화

// 3. 깊이 테스트 on/off 토글
if (bDepth)
    glEnable(GL_DEPTH_TEST);
else
    glDisable(GL_DEPTH_TEST);
```

### 깊이 값 계산
- **카메라 뷰 기준**: 카메라 좌표계에서 깊이를 계산
- **카메라 좌표**: 투영될 화면 방향을 결정
- **낮은 깊이 값**: 카메라에 더 가까움 → 화면에 표시됨
- **높은 깊이 값**: 카메라에서 더 멀음 → 가려짐

---

## glOrtho와 클리핑 영역

### glOrtho 함수
```cpp
glOrtho(left, right, bottom, top, near, far);
```

- **역할**: 직교 투영(orthographic projection)을 위한 클리핑 영역 설정
- **클리핑 영역**: 이 영역 밖의 객체는 렌더링되지 않음

### near와 far 파라미터의 의미
- `near`: 카메라에서 가까운 클리핑 평면까지의 거리
- `far`: 카메라에서 먼 클리핑 평면까지의 거리

### 주의: near > far인 경우
```cpp
glOrtho(-100, 100, -100, 100, -100, 100);  // near=-100, far=100
```

- **Z축 반전**: projection 계산 시 z축이 뒤집힘
- **깊이 비교 반대**: 깊이 테스트의 비교 방향이 반대로 됨
- **일반적인 사용**:
  - 표준: `near < far` (예: near=1, far=500)
  - 반전: `near > far` (예: near=100, far=-100)

---

## 카메라와 좌표계

### 기본 카메라 설정
- **기본 위치**: 원점 (0, 0, 0)
- **기본 방향**: -Z 방향 (OpenGL 오른손 좌표계)
- **기본 업 벡터**: +Y 방향

```cpp
// 카메라 위치 조정
glTranslatef(0.0f, 0.0f, -250.0f);  // 카메라를 -Z 방향으로 250만큼 이동
                                     // = 장면을 +Z 방향으로 250만큼 이동
```

### 좌표계 이해
```
      +Y
       |
       |
       |_______ +X
      /
     /
   +Z (화면 밖으로)
```

- **카메라 시선**: -Z 방향 (화면 안쪽)
- **화면 평면**: XY 평면 (z=0 근처)
- **깊이 방향**: Z축

---

## ⭐ 시험 문제: 원의 가시성 판단 ⭐

### 📌 문제 (교수님 강조 - 시험 출제 예정!)

다음 상황에서 어느 원이 보일까요?

```cpp
// 카메라 설정
// - 위치: 원점 (0, 0, 0)
// - 방향: -Z 방향으로 봄

// 투영 설정
glOrtho(-100, 100, -100, 100, -100, 100);
// near = -100
// far = 100

// 후면 제거: 활성화 ⚠️
glEnable(GL_CULL_FACE);

// 깊이 테스트: 활성화 ⚠️
glEnable(GL_DEPTH_TEST);

// 객체
// - 원 A: z = 10 (XY 평면에 그려진 원, 크기 동일)
// - 원 B: z = 20 (XY 평면에 그려진 원, 크기 동일)
```

**질문**: 원 A와 원 B 중 어느 것이 화면에 보일까요?

### 분석

#### 1. 카메라와 객체의 위치 관계
- **카메라**: (0, 0, 0)에서 -Z 방향을 봄
- **원 A**: z = 10
- **원 B**: z = 20

#### 2. glOrtho 파라미터 해석
```
glOrtho(-100, 100, -100, 100, -100, 100)
near = -100
far = 100
```

**핵심**: `near > far`인지 확인!
- `-100 < 100` → **near < far** (정상 순서)

#### 3. 깊이 계산: near > far일 때 Z축 반전!

**문제를 다시 읽어보니**: 문서에 "**near > far이면 projection 계산 시 z축이 뒤집힘**"

실제 문제 상황을 재해석하면:
- 만약 실제로는 `glOrtho(-100, 100, -100, 100, 100, -100)`처럼
- **near = 100, far = -100** (near > far)라면
- **Z축이 반전**됨!

#### 4. Z축 반전 시 깊이 계산

**정상 (near < far)일 때**:
```
z = near → depth = 0.0 (가까움)
z = far → depth = 1.0 (멀음)

z값이 클수록 멀어짐
```

**반전 (near > far)일 때**:
```
z = near → depth = 0.0 (가까움)
z = far → depth = 1.0 (멀음)

하지만 near > far이므로:
z값이 클수록 가까워짐! (역전)
```

#### 5. 문제 상황 재정리

**가정**: `glOrtho(-100, 100, -100, 100, 100, -100)`
- near = 100
- far = -100
- **near > far** → Z축 반전!

**깊이 값 계산** (반전된 상태):
```
depth = (z - near) / (far - near)
      = (z - 100) / (-100 - 100)
      = (z - 100) / (-200)
      = (100 - z) / 200

원 A (z=10): depth = (100-10)/200 = 90/200 = 0.45
원 B (z=20): depth = (100-20)/200 = 80/200 = 0.40
```

**결과**: 원 B의 depth 값(0.40)이 원 A(0.45)보다 **작음**
→ **원 B가 더 가까움** → 원 B가 보임!

#### 6. 올바른 이해

**Z축 반전 효과** (near > far일 때):
- z 값이 **클수록** depth 값이 **작아짐**
- z 값이 클수록 **카메라에 가까워짐**
- 직관과 반대!

```
정상 (near < far):
z=10  → depth=0.55  (카메라에서 보통)
z=20  → depth=0.60  (카메라에서 더 멀음)
→ 원 A가 보임

반전 (near > far):
z=10  → depth=0.45  (카메라에서 멀음)
z=20  → depth=0.40  (카메라에서 가까움)
→ 원 B가 보임
```

### 🎯 정답: 알 수 없음!

### ⚠️ 함정 주의! ⚠️

**많은 학생들의 오답**:
- ❌ "원 A가 보인다" (z=10이 z=20보다 카메라에 가까우므로)
- ❌ "원 B가 보인다" (near > far로 z축이 반전되므로)

**정답**: ✅ **알 수 없음!**

---

### 💡 핵심 개념: 왜 알 수 없는가?

**문제에서 주어진 정보**:
1. ✓ 카메라 위치: 원점 (0, 0, 0)
2. ✓ 카메라 방향: -Z 방향
3. ✓ glOrtho: (-100, 100, -100, 100, -100, 100)
4. ✓ 깊이 테스트: 활성화
5. ✓ **후면 제거: 활성화** ← 중요!
6. ✓ 원의 위치: A는 z=10, B는 z=20
7. ✓ 원의 크기: 같음

**❗ 문제에서 주어지지 않은 정보**:
- ❌ **원을 그리는 방향 (정점 순서)**
- ❌ **법선 벡터 방향**

### 🔴 결정적 이유: 후면 제거가 활성화되어 있음!

**후면 제거가 비활성화**되어 있다면:
- 깊이 테스트만 고려
- z=10인 원 A가 카메라에 더 가까움
- **원 A가 보임** (명확한 답)

**하지만 후면 제거가 활성화**되어 있으면:
- 법선 벡터 방향이 중요!
- **방향 정보 없이는 전면/후면 판단 불가**
- **답을 알 수 없음!**

---

## 📚 상세 설명: 왜 방향 정보가 필요한가?

### 1️⃣ 후면 제거(Backface Culling)의 원리

**후면 제거란?**
- 카메라가 볼 수 없는 **뒷면을 자동으로 제거**하는 기능
- 렌더링 성능 향상 (불필요한 면을 그리지 않음)
- `glEnable(GL_CULL_FACE)`로 활성화

**전면/후면 판정 방법**:
```
OpenGL의 기본 설정:
- 반시계 방향(CCW, Counter-ClockWise): 앞면 (Front Face)
- 시계 방향(CW, ClockWise): 뒷면 (Back Face)
```

**정점 순서로 법선 벡터 결정**:
- 삼각형의 정점을 A, B, C라고 할 때
- 법선 벡터 = (B-A) × (C-A) (외적)
- 카메라에서 봤을 때 반시계 방향이면 법선이 카메라를 향함 (앞면)
- 카메라에서 봤을 때 시계 방향이면 법선이 카메라 반대 (뒷면)

### 2️⃣ GL_TRIANGLE_FAN으로 원을 그릴 때

**XY 평면에 원을 그리는 두 가지 방법**:

#### 방법 1: 반시계 방향 (CCW) - 법선이 +Z 방향
```cpp
glBegin(GL_TRIANGLE_FAN);
    glVertex3f(0, 0, z);  // 중심점

    // 반시계 방향으로 원주 점들 생성
    for (angle = 0; angle < 2*PI; angle += PI/8) {
        x = radius * cos(angle);
        y = radius * sin(angle);
        glVertex3f(x, y, z);
    }
glEnd();

// 법선 벡터: +Z 방향 (위쪽을 향함)
// 카메라가 -Z 방향을 보면 이 원의 뒷면을 봄 → 후면 제거됨!
```

#### 방법 2: 시계 방향 (CW) - 법선이 -Z 방향
```cpp
glBegin(GL_TRIANGLE_FAN);
    glVertex3f(0, 0, z);  // 중심점

    // 시계 방향으로 원주 점들 생성
    for (angle = 2*PI; angle > 0; angle -= PI/8) {
        x = radius * cos(angle);
        y = radius * sin(angle);
        glVertex3f(x, y, z);
    }
glEnd();

// 법선 벡터: -Z 방향 (아래쪽을 향함)
// 카메라가 -Z 방향을 보면 이 원의 앞면을 봄 → 렌더링됨!
```

**시각화**:
```
        카메라 (원점에서 -Z 방향을 봄)
             ↓
             |
             | 시선
             ↓

    z=10 평면  [원 A]  법선: +Z? -Z?  ← 모름!

    z=20 평면  [원 B]  법선: +Z? -Z?  ← 모름!
```

### 3️⃣ 가능한 모든 시나리오 분석

#### 📊 시나리오 1: 원 A, B 모두 반시계 방향 (법선 +Z)
```
원 A (z=10): 법선 +Z → 카메라(-Z 방향)의 반대 → 뒷면
원 B (z=20): 법선 +Z → 카메라(-Z 방향)의 반대 → 뒷면

결과: 둘 다 후면 제거됨
화면: 아무것도 안 보임 ⬛
```

#### 📊 시나리오 2: 원 A, B 모두 시계 방향 (법선 -Z)
```
원 A (z=10): 법선 -Z → 카메라(-Z 방향)과 같음 → 앞면
원 B (z=20): 법선 -Z → 카메라(-Z 방향)과 같음 → 앞면

둘 다 전면 → 깊이 테스트 적용
z=10 < z=20 → 원 A가 카메라에 더 가까움

결과: 원 A가 원 B를 가림
화면: 원 A만 보임 🔴
```

#### 📊 시나리오 3: 원 A는 반시계(+Z), 원 B는 시계(-Z)
```
원 A (z=10): 법선 +Z → 뒷면 → 후면 제거됨
원 B (z=20): 법선 -Z → 앞면 → 렌더링됨

결과: 원 A는 제거, 원 B만 남음
화면: 원 B만 보임 🔵
```

#### 📊 시나리오 4: 원 A는 시계(-Z), 원 B는 반시계(+Z)
```
원 A (z=10): 법선 -Z → 앞면 → 렌더링됨
원 B (z=20): 법선 +Z → 뒷면 → 후면 제거됨

결과: 원 B는 제거, 원 A만 남음
화면: 원 A만 보임 🔴
```

---

### 🎓 결론 (시험 답안 작성 형식)

**문제에서 주어진 정보**:
- ✅ 카메라 위치: (0, 0, 0)
- ✅ 카메라 방향: -Z 방향
- ✅ 투영 설정: glOrtho(-100, 100, -100, 100, -100, 100)
- ✅ 깊이 테스트: 활성화
- ✅ **후면 제거: 활성화** ⚠️
- ✅ 원의 위치: A(z=10), B(z=20)
- ✅ 원의 크기: 동일

**문제에서 주어지지 않은 정보**:
- ❌ **원을 그리는 방향 (정점 순서)**
- ❌ **법선 벡터의 방향**

**따라서**:
```
후면 제거가 활성화되어 있으므로,
법선 벡터 방향에 따라 전면/후면이 결정됨.

방향 정보가 없으면:
→ 전면/후면 판정 불가
→ 어느 원이 렌더링될지 알 수 없음
→ 답: 알 수 없음
```

**✅ 정답**: **그려지는 방향 정보가 없으므로 전면/후면을 알 수 없다. 따라서 어느 원이 보일지 판단할 수 없다.**

---

### 🔑 핵심 암기 사항 (시험 대비)

1. **후면 제거 활성화 시 필수 정보**:
   - 카메라 위치와 방향 ✓
   - 객체의 위치 ✓
   - **객체의 법선 벡터 방향** ← 필수!

2. **법선 벡터 결정 요소**:
   - GL_TRIANGLE_FAN의 **정점 순서**
   - 반시계(CCW) vs 시계(CW) 방향
   - glFrontFace() 설정

3. **깊이 테스트만 있고 후면 제거가 없으면**:
   - 법선 방향 무관
   - z 값만으로 판정 가능
   - 답: 원 A (z=10이 더 가까움)

4. **후면 제거가 있으면**:
   - 법선 방향 필수
   - 방향 정보 없으면 **답 없음**

---

## 핵심 교훈

**후면 제거를 사용할 때 필수 정보**:
1. 카메라 위치와 방향
2. 객체의 위치
3. **객체의 법선 벡터 방향** ← 중요!

**법선 벡터를 결정하는 요소**:
- GL_TRIANGLE_FAN의 정점 순서
- 반시계 vs 시계 방향
- glFrontFace(GL_CCW) 또는 glFrontFace(GL_CW) 설정

---

## 추가 시나리오

### 시나리오 1: 깊이 테스트 비활성화
```cpp
glDisable(GL_DEPTH_TEST);
```
- **결과**: 나중에 그려진 원이 보임 (그리기 순서에 따라 결정)

### 시나리오 2: near > far (Z축 반전)
```cpp
glOrtho(-100, 100, -100, 100, 100, -100);  // near=100, far=-100
```
- **Z축 반전**: 깊이 비교가 반대로 됨
- **결과**: 원 B가 보일 수 있음 (projection 계산이 바뀜)

### 시나리오 3: 카메라 위치 변경
```cpp
glTranslatef(0.0f, 0.0f, -50.0f);  // 카메라를 z=-50으로 이동
```
- **카메라에서의 상대 거리**:
  - 원 A: z = 10 - (-50) = 60
  - 원 B: z = 20 - (-50) = 70
- **결과**: 여전히 원 A가 더 가까움

---

## 핵심 포인트 요약

1. **깊이 버퍼**: 카메라로부터의 거리를 기준으로 픽셀의 가시성 결정
2. **glOrtho**: 클리핑 영역 설정, near > far이면 Z축 반전 주의
3. **카메라 좌표**: 투영 계산의 기준점, 기본은 원점에서 -Z 방향
4. **깊이 비교**: 낮은 깊이 값(카메라에 가까움)이 우선
5. **후면 제거**: 폴리곤의 앞/뒤면 판정 (별도의 개념)

---

## 실습 예제

### 깊이 테스트 효과 확인
```cpp
// 3-7-2.cpp 참고
GLboolean bDepth = GL_TRUE;

void Keyboard(unsigned char key, int x, int y) {
    if (key == 'd' || key == 'D') {
        bDepth = !bDepth;  // 깊이 테스트 토글
    }
}

void RenderScene(void) {
    if (bDepth)
        glEnable(GL_DEPTH_TEST);
    else
        glDisable(GL_DEPTH_TEST);

    // 객체 렌더링...
}
```

- **d 키**: 깊이 테스트 on/off 전환
- **효과**: 깊이 테스트를 끄면 겹치는 면들이 그리는 순서대로 표시됨
